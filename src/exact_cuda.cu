/*! \file exact_cuda.cu
 *  \brief Function definitions for the cuda exact Riemann solver.*/

#ifdef CUDA

#include<cuda.h>
#include<math.h>
#include<stdio.h>
#include"global.h"
#include"global_cuda.h"
#include"exact_cuda.h"


/*! \fn Calculate_Exact_Fluxes(Real *dev_bounds_L, Real *dev_bounds_R, Real *dev_flux, int nx, int ny, int nz, int n_ghost, Real gamma, int dir)
 *  \brief Exact Riemann solver based on the Fortran code given in Sec. 4.9 of Toro (1999). */
__global__ void Calculate_Exact_Fluxes(Real *dev_bounds_L, Real *dev_bounds_R, Real *dev_flux, int nx, int ny, int nz, int n_ghost, Real gamma, int dir)
{
  // get a thread index
  int blockId = blockIdx.x + blockIdx.y*gridDim.x;
  int tid = threadIdx.x + blockId * blockDim.x;
  int zid = tid / (nx*ny);
  int yid = (tid - zid*nx*ny) / nx;
  int xid = tid - zid*nx*ny - yid*nx;

  int n_cells = nx*ny*nz;
  int o1, o2, o3;
  if (dir == 0) {
    o1 = 1; o2 = 2; o3 = 3;
  }
  if (dir == 1) {
    o1 = 2; o2 = 3; o3 = 1;
  }
  if (dir == 2) {
    o1 = 3; o2 = 1; o3 = 2;
  }

  Real dl, vxl, vyl, vzl, pl, cl; //density, velocity, pressure, sound speed (left)
  Real dr, vxr, vyr, vzr, pr, cr; //density, velocity, pressure, sound speed (right)
  Real ds, vs, ps, Es; //sampled density, velocity, pressure, total energy
  Real vm, pm; //velocity and pressure in the star region

  #ifdef DE
  Real gel, ger;
  #endif


  // Each thread executes the solver independently
  //if (xid > n_ghost-3 && xid < nx-n_ghost+1 && yid < ny && zid < nz) 
  if (xid < nx && yid < ny && zid < nz) 
  {
    // retrieve primative variables
    dl  = dev_bounds_L[            tid];
    vxl = dev_bounds_L[o1*n_cells + tid]/dl;
    vyl = dev_bounds_L[o2*n_cells + tid]/dl;
    vzl = dev_bounds_L[o3*n_cells + tid]/dl;
    pl  = (dev_bounds_L[4*n_cells + tid] - 0.5*dl*(vxl*vxl + vyl*vyl + vzl*vzl)) * (gamma - 1.0);
    pl  = fmax(pl, (Real) TINY_NUMBER);
    #ifdef DE
    gel = dev_bounds_L[5*n_cells + tid]/dl;
    #endif
    dr  = dev_bounds_R[            tid];
    vxr = dev_bounds_R[o1*n_cells + tid]/dr;
    vyr = dev_bounds_R[o2*n_cells + tid]/dr;
    vzr = dev_bounds_R[o3*n_cells + tid]/dr;
    pr  = (dev_bounds_R[4*n_cells + tid] - 0.5*dr*(vxr*vxr + vyr*vyr + vzr*vzr)) * (gamma - 1.0);  
    pr  = fmax(pr, (Real) TINY_NUMBER);
    #ifdef DE
    ger = dev_bounds_R[5*n_cells + tid]/dr;
    #endif

    // compute sounds speeds in left and right regions
    cl = sqrt(gamma * pl / dl);
    cr = sqrt(gamma * pr / dr);
    
    // test for the pressure positivity condition
    if ((2.0 / (gamma - 1.0)) * (cl+cr) <= (vxr-vxl))
    {
      // the initial data is such that vacuum is generated
      //printf("Vacuum is generated by the initial data.\n");
      //printf("%f %f %f %f %f %f\n", dl, vxl, pl, dr, vxr, pr);
    }

    // Find the exact solution for pressure and velocity in the star region
    starpv(&pm, &vm, dl, vxl, pl, cl, dr, vxr, pr, cr, gamma);
 
    //sample the solution at the cell interface
    sample(pm, vm, &ds, &vs, &ps, dl, vxl, pl, cl, dr, vxr, pr, cr, gamma);
 
    // calculate the fluxes through the cell interface
    dev_flux[tid] = ds*vs;
    dev_flux[o1*n_cells + tid] = ds*vs*vs+ps;
    if (vs >= 0)
    {
      dev_flux[o2*n_cells + tid] = ds*vs*vyl;
      dev_flux[o3*n_cells + tid] = ds*vs*vzl;
      #ifdef DE
      dev_flux[5*n_cells + tid] = ds*vs*gel;
      #endif
      Es = (ps/(gamma - 1.0)) + 0.5*ds*(vs*vs + vyl*vyl + vzl*vzl);
    }
    else
    {
      dev_flux[o2*n_cells + tid] = ds*vs*vyr;
      dev_flux[o3*n_cells + tid] = ds*vs*vzr;
      #ifdef DE
      dev_flux[5*n_cells + tid] = ds*vs*ger;
      #endif
      Es = (ps/(gamma - 1.0)) + 0.5*ds*(vs*vs + vyr*vyr + vzr*vzr);
    }
    dev_flux[4*n_cells + tid] = (Es+ps)*vs;
    dev_flux[5*n_cells + tid] = ps*vs/(gamma-1.0);
    //printf("%3d %f %f %f %f\n", tid, dl, dr, gel, ger);
    //printf("%d %d %f %f %f %f %f %f %f %f\n", xid, yid, dl, dr, vxl, vxr, pl, pr, dev_flux[2*n_cells + tid], dev_flux[3*n_cells + tid]);
    //if (dir == 2 && xid == 130 && yid == 6 && zid == 81) {
    //  printf("%f %f %f %f %f %f %f %f %f\n", dl, dr, vxl, vxr, pl, pr, gel, ger, dev_flux[tid]);
    //}
   //if (dir == 1) { 
    //if (dev_flux[tid] != dev_flux[tid]) printf("%d %f %f %f %f %f %f\n", tid, dl, dr, vxl, vxr, pl, pr);
   //}

  }

}


__device__ Real guessp(Real dl, Real vxl, Real pl, Real cl, Real dr, Real vxr, Real pr, Real cr, Real gamma)
{
  // purpose:  to provide a guessed value for pressure
  //    pm in the Star Region. The choice is made
  //    according to adaptive Riemann solver using
  //    the PVRS and TSRS approximate Riemann
  //    solvers. See Sect. 9.5 of Toro (1999)
 
  Real gl, gr, ppv, pm;
  const Real TOL = 1.0e-6;
 
  // compute guess pressure from PVRS Riemann solver
  ppv = 0.5*(pl + pr) + 0.125*(vxl - vxr)*(dl + dr)*(cl + cr);
 
  if (ppv < 0.0) ppv = 0.0;
  // Two-Shock Riemann solver with PVRS as estimate
  gl = sqrt((2.0 / ((gamma + 1.0)*dl))/(((gamma - 1.0) / (gamma + 1.0))*pl + ppv));
  gr = sqrt((2.0 / ((gamma + 1.0)*dr))/(((gamma - 1.0) / (gamma + 1.0))*pr + ppv));
  pm = (gl*pl + gr*pr - (vxr-vxl))/(gl + gr);

  if (pm < 0.0) pm = TOL;

  return pm;
}
 
 
__device__ void prefun(Real *f, Real *fd, Real p, Real dk, Real pk, Real ck, Real gamma)
{
  // purpose:  to evaluate the pressure functions
  // fl and fr in the exact Riemann solver
  // and their first derivatives
 
  Real qrt;
 
  if (p <= pk) {
    // rarefaction wave
    *f = (2.0 / (gamma - 1.0))*ck*(pow((p/pk), Real (((gamma - 1.0)/(2.0 * gamma)))) - 1.0);
    *fd = (1.0/(dk*ck))*pow((p/pk), Real (-((gamma + 1.0)/(2.0 * gamma))));
  } 
  else 
  {
    // shock wave
    qrt = sqrt(((2.0 / (gamma + 1.0)) / dk)/((((gamma - 1.0) / (gamma + 1.0)) * pk) + p));
    *f = (p - pk)*qrt;
    *fd = (1.0 - 0.5*(p - pk)/((((gamma - 1.0) / (gamma + 1.0)) * pk) + p))*qrt;
  }
}
 
 
__device__ void starpv(Real *p, Real *v, Real dl, Real vxl, Real pl, Real cl, Real dr, Real vxr, Real pr, Real cr, Real gamma)
{
  // purpose:  Uses Newton-Raphson iteration 
  // to compute the solution for pressure and
  // velocity in the Star Region
 
  const int nriter = 20;
  const Real TOL = 1.0e-6;
  Real change, fl, fld, fr, frd, pold, pstart;
 
  //guessed value pstart is computed
  pstart = guessp(dl, vxl, pl, cl, dr, vxr, pr, cr, gamma);
  pold = pstart;
 
  int i = 0;
  for (i=0 ; i <= nriter; i++) {
    prefun(&fl, &fld, pold, dl, pl, cl, gamma);
    prefun(&fr, &frd, pold, dr, pr, cr, gamma);
    *p = pold - (fl + fr + vxr - vxl)/(fld + frd);
    change = 2.0*fabs((*p - pold)/(*p + pold));

    if (change <= TOL) break;
    if (*p < 0.0) *p = TOL;
    pold = *p;
  }
  if (i > nriter) {
    //printf("Divergence in Newton-Raphson iteration. p = %e\n", *p);
    //exit(0);
  }

  // compute velocity in star region
  *v = 0.5*(vxl + vxr + fr - fl);

}
 
 
__device__ void sample(const Real pm, const Real vm, Real *d, Real *v, Real *p,
      Real dl, Real vxl, Real pl, Real cl, Real dr, Real vxr, Real pr, Real cr, Real gamma)
{
  // purpose:  to sample the solution throughout the wave
  //   pattern. Pressure pm and velocity vm in the
  //   star region are known. Sampled
  //   values are d, v, p.
 
  Real c, sl, sr;
 
  if (vm >= 0) // sampling point lies to the left of the contact discontinuity
  {
    if (pm <= pl) // left rarefaction
    {    
      if (vxl - cl >= 0) // sampled point is in left data state
      {   
        *d = dl;
        *v = vxl;
        *p = pl;
      }
      else 
      {
        if (vm - cl*pow(pm/pl, Real ((gamma - 1.0)/(2.0 * gamma))) < 0) // sampled point is in star left state
        {
          *d = dl*pow(pm/pl, Real (1.0/gamma));
          *v = vm;
          *p = pm;
        } 
        else // sampled point is inside left fan
        {
          c = (2.0 / (gamma + 1.0))*(cl + ((gamma - 1.0) / 2.0)*vxl);
          *v = c;
          *d = dl*pow(c/cl, Real (2.0 / (gamma - 1.0)));
          *p = pl*pow(c/cl, Real (2.0 * gamma / (gamma - 1.0)));
        }
      }
    } 
    else // left shock
    { 
      sl = vxl - cl*sqrt(((gamma + 1.0)/(2.0 * gamma))*(pm/pl) + ((gamma - 1.0)/(2.0 * gamma)));
      if (sl >= 0) // sampled point is in left data state
      {
        *d = dl;
        *v = vxl;
        *p = pl;
      } 
      else // sampled point is in star left state
      { 
        *d = dl*(pm/pl + ((gamma - 1.0) / (gamma + 1.0)))/((pm/pl)*((gamma - 1.0) / (gamma + 1.0)) + 1.0);
        *v = vm;
        *p = pm;
      }
    } 
  } 
  else // sampling point lies to the right of the contact discontinuity
  { 
    if (pm > pr) // right shock
    {
      sr = vxr + cr*sqrt(((gamma + 1.0)/(2.0 * gamma))*(pm/pr) + ((gamma - 1.0)/(2.0 * gamma)));
      if (sr <= 0) // sampled point is in right data state
      {
        *d = dr;
        *v = vxr;
        *p = pr;
      } 
      else // sampled point is in star right state
      { 
        *d = dr*(pm/pr + ((gamma - 1.0) / (gamma + 1.0)))/((pm/pr)*((gamma - 1.0) / (gamma + 1.0)) + 1.0);
        *v = vm;
        *p = pm;
      }
    } 
    else // right rarefaction
    { 
      if (vxr + cr <= 0) // sampled point is in right data state
      { 
        *d = dr;
        *v = vxr;
        *p = pr;
      } 
      else 
      {
        if (vm + cr*pow(pm/pr, Real ((gamma - 1.0)/(2.0 * gamma))) >= 0) // sampled point is in star right state
        {    
          *d = dr*pow(pm/pr, Real (1.0/gamma));
          *v = vm;
          *p = pm;
        } 
        else // sampled point is inside right fan
        {    
          c = (2.0 / (gamma + 1.0))*(cr - ((gamma - 1.0) / 2.0)*vxr);
          *v = -c;
          *d = dr*pow(c/cr, Real (2.0 / (gamma - 1.0)));
          *p = pr*pow(c/cr, Real (2.0 * gamma / (gamma - 1.0)));
        }
      }
    } 
  }
}



#endif //CUDA
